# Временные объекты
- **Анонимный объект**, созданный компилятором для хранения *временного значения*
	• Для инициализации const ссылки на объект «другого» типа;
	• Для сохранения возвращаемого значения из функции пользовательского типа (UDT = user defined type)
		• UDT f() ------ f();
		• UDT1 + UDT2 + UDT3
	• Для сохранения результата explicit приведения к UDT.

• Уничтожаются
	• После выхода const ссылки из области видимости;
	• После “;”

## Константный ссылки
---
```c++
#include <iostream>
struct A
{
    int a;
    
	A(int t = 0) : a{t} { std::cout << "ctor " << a << std::endl; }

    ~A()
    {
        std::cout << "dtor " << a << std::endl;
        a = -1;
    }
};

const A &
g(const A &o) //скопирует ссылку и вернёт 
{
    return o;
}

const A
f()
{
    return 42;
}

int
main()
{

    const A &a = A(3); //временный объект (ctor 3)
    std::cout << a.a << std::endl; // 3

    const A &c = f(); //ctor 42
    std::cout << c.a << std::endl; //42

    const A &b = g(4); // ctor 4; dtor 4
    std::cout << b.a << std::endl; // UB (“-1”)

    const A *p = &g(5); //ctor 5; dtor 5
    std::cout << p->a << std::endl; // UB

    return 0; //dtor 42; dtor 3;
}
```
---

- По ссылке не возвращаем, возвращаем по значению
- Константные ссылки продлевают жизнь объекта

# Когда нужны указатели на C++
- Для взаимодействия с Си (использования библиотек C)

- *Forward declaration* для избавления от зависимостей между модулями
компиляции
	a.h: `#include<b.h> class A { B b;} `; // Надо заменить include на class B и исп. указатель B * b;

	b.h: `#include<a.h> class B { A a;} `;

- **Для передачи объектов, для ссылок на объекты, для полиморфизма** лучше использовать *ссылки* или *умные указатели* (smart pointers)

- **Если хочется nullptr**, то либо `std::optional`, либо другая инкапсуляция

# Вопросы (что будет напечатно)

```c++
1. int &a = 5; std::cout << a << std::endl; //error

2. int *p = nullptr; int*& rp = p; p = new int {5}; std::cout << *rp; //5

3.  struct A { 
		int x; 
		A(int x):x{x} {}
	};

	void swap(A& a, A& b) 
	{	
		A t{a}; 
		a = b; 
		b = t;
	}
	
	int main()
	{
		A o1{1}, o2{2};
		swap(o1, o2);
		std::cout << o1.x << std::endl; //2
	}

4.  double pi = 3.14; 
	
	const int &ref = pi; //создатся новый временный объект (прикол именно из-за int, если бы был double, проблем бы не было)
	
	pi = 1.0; 
	
	std::cout << ref << std::endl; //3
```

# Конструкторы и декструкторы

*Конструкторы* создают объект, *деструкторы* уничтожают объект

---
```c++
#include <iostream>
class OptionalInt
{
    int value_{};
    bool hasValue_{false};

  public:
    OptionalInt() : value_{0}  { std::cout << "default ctor" << std::endl; } //default
    
	/*explicit*/ OptionalInt(int v) : value_{v}, hasValue_{true} { std::cout << "conversion ctor" << std::endl; }
    
	// copy ctors
    OptionalInt(OptionalInt &other) : value_{other.value_}, hasValue_{other.hasValue_}
    {
        std::cout << "copy" << std::endl;
    }
    
	OptionalInt(const OptionalInt &other) : value_{other.value_}, hasValue_{other.hasValue_}
    {
        std::cout << "const copy" << std::endl;
    }
    
	// move ctor
    OptionalInt(OptionalInt &&) = delete;
    
	// dtor
    ~OptionalInt() {} // delete value_;};
    
	// user ctor
    OptionalInt(int a, int b) : OptionalInt(a + b) { std::cout << "user" << std::endl; }
    
	void
    dump()
    {
        std::cout << value_ << " " << hasValue_ << std::endl;
    }
};

void
foo(OptionalInt x)
{
    x.dump();
}

int
main()
{
    OptionalInt a; //вызывается default ctor;
	
	OptionalInt b{1}; //вызывается conversion ctor;
	
	const OptionalInt c{b}; //вызывается copy ctor;
	
	OptionalInt d{c}; //вызывается const copy ctor, так как c - const объект;
	
	OptionalInt e{std::move(b)}; //вызывается move ctor;
	
	OptionalInt f{10, 50}; //user

	
	OptionalInt i = false; // implicit conversion
    foo(false);            // implicit conversion
}
```
---

Ключевое слово `explicit` запрещает неявное преобразование в конструкторе

**Виды конструкторов**:
    - default
    - преобразований
    - копирования (по другому объекту создаём другой объект)
      - лучше использовать константные ссылки
    - move конструкторы
  
## Особенности 
- Если в классе явно не описан никакой конструктор, то конструктор умолчания генерируется автоматически и выполняет инициализацию.

- Если в классе явно не описан конструктор копирования, то он генерируется автоматически и реализует почленное копирование

- Если в классе явно не описан деструктор, то он генерируется автоматически и вызывает деструкторы полей.

- Подробная таблица будет далее

## Порядок вызова конструкторов и деструкторов
При вызове *конструктора* класса выполняются:
  1. конструкторы базовых классов (если есть наследование),
  2. конструкторы всех вложенных объектов в **порядке объявления в классе**, включая инициализацию в конструкторах
  3. конструктор: *инициализация в порядке объявления*, потом тело
```c++
struct A {
	int b;
	int a{1};
	A(): b{a + 1} {} //err a = 1, b - UB
};
```

*Деструкторы* выполняются в обратном порядке:
  1. собственный деструктор
  2. деструкторы полей в обратном порядке
  3. деструкторы базовых классов (если есть наследование).

## Указатель this
- Указатель на текущий объект, присутствует в каждом методе класса
- Неявный первый параметр всех **нестатических** методов (класса)

## Конструктор копирования и оператор присваивания
**Конструктор копирования**:
  1. Возвращение из функции объекта по значению (-copy elision)
  2. Передача в функции объекта по значению (аргумент)
  3. Конструирование на основе другого объекта того же класса
  4. Конструирование с помощью списка инициализаторов { }
  5. Временный объект

**Оператор присваивания** вызывается, если объект уже
инициализирован
```c++
A& operator = (A& other) {…; return *this;}
A a, b; //a уже создан, поэтому вызовется оператор
a = b; // operator=
```
- Copy Semantics – Move Semantics – Copy-And-Swap

# Время и жизни, владение
---
```c++
#include <iostream>
class OptionalInt
{
    int *value_{nullptr};
    bool hasValue_{false};

  public:
	OptionalInt() { std::cout << "default ctor" << std::endl; }
    
	OptionalInt(int v) : value_{new int{v}}, hasValue_{true} { std::cout << "conversion ctor" << std::endl; }
    
	// copy ctors
    OptionalInt(OptionalInt &other) : value_{new int{*other.value_}}, hasValue_{other.hasValue_} //создание нового объекта
    {
        std::cout << "copy" << std::endl;
    }

    OptionalInt(const OptionalInt &other) : value_{new int{*other.value_}}, hasValue_{other.hasValue_}
    {
        std::cout << "const copy" << std::endl;
    }

	OptionalInt &operator=(OptionalInt &other) //изменяем существующий объект
	{   
		std::swap(value_, other.value _);
    	std::swap(hasValue_, other.hasValue _);
    	std::cout << " operator=" << std::endl;
		return *this;
 	}

	~OptionalInt()
    {
        delete value_;
        std::cout << "dtor " << value_ << std::endl;
    }
    
	int *
    getValue()
    {
        return value_;
    }
};

int
main()
{
    OptionalInt b;
    {
        OptionalInt a{1};
        b = a;
    }
   
	std::cout << (*b.getValue())++ << std::endl;
 
	std::cout << (*b.getValue())++ << std::endl;
    
	return 0;
}
```
---

# Правила автоматической генерации конструктора
![](_resources/Pasted%20image%2020260226115322.png)


# RAII = Resource acquisition is initialization
- **Программная идиома**: выделение ресурса неразрывно совмещается с инициализацией, а освобождение — с уничтожением объекта.

- Борьба с утечками ресурса, использованием неинициализированных ресурсов

- Упрощение использования, повышение читаемости кода

- Конструктор-деструктор

- Умные указатели (позже)

# Правило трех, пяти
- Если классу нужен один из следующих трех методов, то, скорее всего, ему понадобятся и два других:
  - Деструктор, конструктор копирования, оператор присваивания копированием

- Правило пяти:
  - Деструктор, конструктор копирования, оператор присваивания
копированием.
  - Конструктор перемещения, оператор присваивания перемещением.

# Категории значений в C++
**Identity** (идентичность)— есть ли у объекта имя/адрес
**Moveable** (можно перемещать)— безопасно ли «забрать» его ресурсы

**Классическая схема (до C++11)**
  - lvalue (left value) — то, что может стоять слева от присваивания
  - rvalue (right value) — то, что может стоять **только** справа

**Современная схема (C++11 и новее)**
  - *glvalue* (generalized lvalue) — имеет идентичность
  - *rvalue* — может быть перемещено
    -  нельзя получить адрес rvalue в памяти (отсутствие identity)
    - не могут находиться в левой части оператора присваивания или составного присваивания
    - могут использоваться для инициализации константной lvalue-ссылки или rvalue-ссылки, при этом время жизни объекта расширяется до времени жизни ссылки
  
  - *lvalue* — glvalue, но не xvalue (имеет идентичность, нельзя перемещать)
        - *Интуитивно*: объект с именем или адресом
        - *Пример*: int a; ++a; “xxx”, a[5];
  - *xvalue* (eXpiring value) — имеет идентичность и может быть перемещено
    - *Пример*: std::move(x), A().member, static_cast<A&&>(a) 
  - *prvalue* (pure rvalue) — не имеет идентичности, может быть перемещено
    - Интуитивно: временные значения, литералы (кроме строковых)
    - Пример: 42, x + y, &x, A(), a++, this, [](int x){ return x; } // лямбда-выражение

# Семантика переноса. Motivation
- **Семантика переноса (Move Semantics)**— возможность передать владение ресурсами от одного объекта к другому без копирования.
  - Вместо **глубокого копирования** (дорого) — просто **перезаписываем указатели** (быстро) и обнуляем источник.

- **Преимущества**
  - Нет доп расходов для временных объектов
  - Позволяет создавать типы, которые можно только перемещать (уникальные указатели)
  - Избавляет от лишних копирований в контейнерах

- **rvalue-ссылка (&&)**

- **std::move** преобразует lvalue в rvalue, разрешая перенос

- Конструктор перемещения и операция присваивания перемещением

## Пример 1

---
```c++
#include <iostream>
class Res
{
  public:
    int *data;
    
    Res(int value) : data(new int(value)) {}
    
    ~Res() { delete data; }

    Res(const Res &other) : data(new int(*other.data)) { std::cout << "copy ctor" << std::endl; }

    Res &
    operator=(const Res &other)
    {
        if (this != &other) {
            *data = *other.data;
        }
        std::cout << "copy=" << std::endl;
        return *this;
    }

    Res(Res &&other) noexcept : data(other.data) //забираем указатель
    {                      
        other.data = nullptr; // обнуляем источник
        std::cout << "move ctor" << std::endl;
    }
    
    Res &
    operator=(Res &&other) noexcept
    {
        if (this != &other) {
            delete data;          // освобождаем свой ресурс
            data = other.data;    // забираем указатель
            other.data = nullptr; // обнуляем источник
        }
        std::cout << "move=" << std::endl;
        // == std::swap(data, other.data);
        return *this;
    }
};

int
main()
{
    Res a{1}, b{a}, c{std::move(a)};
}
```
---

## Пример 2
---
```c++
using T = HugeClassWithManyPointersAndRefs

void swap(T& a, T& b)
{
    T tmp{std::move(a)};
    a = std::move(b);
    b = std::move(tmp);
}
```
---


move используется компилятором вместо копирования для xvalue:
- возврата по значению из функции автоматических переменных
- временных объектов
- нестатические поля rvalue
- https://en.cppreference.com/w/cpp/language/value_category

# RVO и NRVO ([Named] Return Value Optimization)

---
```c++
#include <iostream>
struct A
{
    int i;
    A(const A &a) : i{a.i} { std::cout << "const copy " << i << std::endl; }
    A(A &a) : i{a.i} { std::cout << "copy " << i << std::endl; }
    A(int n = 0) : i{n} { std::cout << "user " << i << std::endl; }
    A(A &&a) : i{a.i} { std::cout << "move " << i << std::endl; };
    A(const A &&a) : i{a.i} { std::cout << "const move " << i << std::endl; }
};

A
createRVO()
{
    return A(22);
}

A
createNRVO()
{
    A a{33};
    return a;
}

A
createNRVO2(bool flag)
{
    A a{1}, b{2};
    if (flag) {
        return a;
    } else {
        return b;
    }
}

int
main(int argc, char **argv)
{
    A a = createRVO();       // user 22 + move 22 + move 22 => user 22
    A b = createNRVO();      // user 33 + move 33 + move 33 => user 33
    A c = createNRVO2(argc); // user 1+ user 2 + move 1 + move 1 => u1 + u2 + move 1
}
```
---

## Рубрика ЭЭЭЭксперименты

```shell
-std=c++14 -fno-elide-constructors // отменяет оптимизацию move семантики
```

`godbolt.org`


# Copy elision и семантика языка
- Copy elision: RVO, NRVO, инициализация вр. объектом,
- Если выражение prvalue, результирующий объект инициализируется напрямую без вызова copy or move constructor

![](_resources/Pasted%20image%2020260228202208.png)

## Пример
![](_resources/Pasted%20image%2020260228202240.png)

# Синтаксис Friend
- Друг класса – это функция, не являющаяся членом этого класса, но имеющая доступ к его private и protected членам.
- «Дружба» предоставляется, а не запрашивается
- Не наследуется, не транзитивно
- Антипаттерн, нарушает инкапсуляцию, может применяться для тестов и перегруженных операций

---
 ```c++
class B;

class A {
	int privFunc(B &b);
	
  public:
	int pubFunc(B &b);
};

class B {
	int v_{};
	
	friend int A::pubFunc(B &b);
	
	friend int foo (B &b); // не метод
	// friend class A;
};

int A::pubFunc(B &b) { return b.v_;}; // ok;
int A::privFunc(B &b) { return b.v_;}; // err;
 ```
---

## Пример 2
---
```c++
#include <iostream>

class SecretHolder {

	int secret{0};

  public:
	SecretHolder(int secret): secret(secret) {}
	
	bool operator==(int value) const {
		return value == secret;
	}
	
	friend bool operator==(int value, const SecretHolder &other);
};

bool operator==(int value, const SecretHolder &other); {
	return value == other.secret;
}

int main()
{
	SecretHolder secret(42);
	
	if (secret == 12)
		std::cout << "1" << std::endl;

	if (12 == secret)
		std::cout << "2" << std::endl;

	return 0;
}
```
---

# Статический полиморфизм. Перегрузка функций
- Функции перегруженные – если они в одной области видимости (scope) и имеют одинаковые имена
-  Перегруженные функции при одинаковых параметрах не могут иметь разные
	- тип возвращаемого значения
	- спецификатор исключения
	 - delete
## Пример 1
```c++
void foo();
char foo(); // ошибка
void foo(int x);
void foo(int x) noexcept; // ошибка
void foo(double x);
void foo(double) = delete; // ошибка
```

## Пример 2
- Не перегрузка, а совпадение
```c++
void foo(int *x) { }
void foo(int x[]) { } // redefinition

void foo(int x) { }
void foo(const int x) { } // redefinition
```

# Область видимости
- перегруженные функции находятся в одной области видимости

## Пример 1
---
```c++
#include<iostream>

namespace A{
	void foo(int x) {std::cout << 1 << std::endl;}
}

namespace A::B{
	void foo(float x) {std::cout << 2 << std::endl;}
	
	void bar() {foo(0);}
}

int main()
{
	A::B::bar(); // 2
	return 0;
}
```
---
## Пример 2
```c++
#include <iostream>

namespace A{
	void foo(int x) {std::cout << "1" << std::endl;}
}

namespace B{
	void foo(float x) {std::cout << "2" << std::endl;}
}

namespace C{
	using namespace A;
	using namespace B;
	void bar() {foo(2.0);}
}

int main()
{
	C::bar(); //Error
	return 0;
}
```

# Разрешение вызова перегруженной функции
1. Построение множества кандидатов (candidate functions)
	- имя и scope
2. Построение viable functions путем сокращения candidate functions
	- сопоставление количества и типов соответствующих параметров
		- + неявные преобразования
		- + variadic
		- + default значения
		- - rvalue arg with const lvalue reference param
		- - user-defined conversions, если более 1

3. Ранжирование неявных преобразований для построения best viable function
	 1. Для каждой пары viable f1 и f2, для каждой пары i-ого параметра и аргумент ранжируются неявные преобразования
	2. f1 лучше f2 если 1) для всех аргументов неявные преобразования к f1 не хуже и 
		- существует хотя бы один аргумент с лучшим преобразованием 
		- много других правил (https://en.cppreference.com/w/cpp/language/overload_resolution#Viable_functions)

# Приоритет неявных преобразований
1. точное совпадение:
	- lvalue to rvalue, qualifiers (const, ..)

2. расширение (promotion): целочисленное, floating-point
	`integer`: `bool`, `(signed, unsigned) char`, `short` в `int`, иногда `unsigned short` в `unsigned`, `floating-point` : `float` в `double`

3. Преобразование (conversion)
	1. стандартное (допустимые неявные преобразования примитивных типов, указателей )
	2. user-defined
	3. ellipsis (variadic) …
	4. https://en.cppreference.com/w/cpp/language/overload_resolution

## Пример
---
```c++
#include<iostream>

struct A {
	A(int x) {}
};

void f (A a, int x) {std::cout << "1" << std::endl;}

void f (int x, A a) {std::cout << “2" << std::endl;}

int main()
{
	f(1,1); // ambiguous
}
```
---
