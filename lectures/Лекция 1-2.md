# Вводная информация
- Валерий Николаевич Игнатьев
- Курс: *Системы программирования*

# Отчётность
- Коллоквиум (третья декада апреля) - письменно
	- 5 задач на C++
	- 5 задач на формальные языки
- Домашнее задания
- Пратикум

# О чём курс. Системы программирования
- **Система программирования (СП)** - это комплекс программных средств для разработки ПО:
	- Среды разработки (IDE, редакторы кода)
	- Компилятор, отладчик, системы автоматизации сборки (make, cmake, autotools)
	- Системы контроля версий (git, svn, ...)
	- Средства тестирования, статического и динамического анализа
	- Project Management (PM) (gitlab, github, jiira, asana, MS Project)
	- Библлиотеки, СУБД, средства контейнеризации, облачные платформы

- Объектно-ориентированная парадигма на примере C++
- Формальные языки и грамматики
- Основы конструирования транслятора
- Прикладные средства: регулярные выражения (regex), системы контроля версий, `bash`,...
- Жизненный цикл программного продукта и программные средства для его поддержки

# Ссылки
- Материалы по курсу:
	- https://moodle.cs.msu.ru/course/view.php?id=133
	- https://github.com/blackav/cmc-cpp-seminars
	- https://cmcmsu.info/2course/

# Развития ЯП. Парадигмы
- программирование в машинных языках
- языки ассемблера
- Парадигмы:
	- **императивная** (последовательность команд)
		- процедурные языки (COBOL, FORTRAN, ALGOL, PL/l, BASIC, C)
	- **объекто-ориентированная** (ООП): Simula, C++, python, Java, C#, PHP
- Декларативные ЯП
	- **функциональная парадигма** (Lisp, Scheme)
	- **логическая парадигма**: Prolog
	- **DSL** (domain-specific): SQL, awk, html, json, xml, shell script, Regex, yaac, graphiz

# Объектная парадигма
- Объект = данные (состояние) + код (поведение)
- X = X+Y -> x.set(x.add(y))

- Данные = поля (fields), свойства, атрибуты
- Поведение = методы (methods)

- **Класс** - это механизм (тип данных) для определения одинаковых объектов
- **Объект класса** (object, instance) - переменная типа класс или экземпляр класса

- **_Инкапсуляция_** - защита данных и кода от произвольного доступа "внешнего" кода

# Иерархия и структура
- **Наследование** - механизм, с помощью которого один объект (произвольного класса) приобретает свойства другого объекта (родительского, базового класса)
- **Полиморфизм** - механизм, позволяющий использовать один и тот же интерфейс для похожих действий
	- выбор поведения в завимисоти от контекста
	- один интерфейс - много методов
		- статический
		- динамический
		- параметрический
## Пример
- Многоугольники
	- треугольник
	- четырёхугольник
		- параллелограмм
			- прямоугольник
			- квадрат
		- трапеция

- Квадрат: Параллелограмма + стороны ()

## Пример кода на полиморфизм
---
```c++
#include <stdio.h>
#include <string.h>
void add(int a, int b)
{
	printf("%d + %d = %d\n", a, b, a+b);
}
void add(char a, char b)
{
	printf("%c + %c = %c\n", a, b, a+b);
}
void add(char* a, char* b)
{
	printf("%s + %s = ", a, b);
	strcpy(a + strlen(a), b);
	printf("%s\n", a);
}

int main()
{
	add(1,2);
	add('1', '2');
	char a[5] = "1";
	char b[] = "2";
	add(a, b);
}
```
---
Здесь каждая функция зависит от *данных*, которые она получает

# Постулаты ООП
- **Абстракция**
	- иерархия и структура
- **Инкапсуляция**
	- защита данных и кода, скрытие деталей реализации
	- состояние + поведение
- **Наследование**
	- переисполнение кода
- **Полиморфизм**

# Декомпозиция задачи
- Многократное дробление большой проблемы на части (классы, объекты), которые решают отдельные подзадачи

# Принципы объектно-ориентированной декомпозиции задачи
1. Компоненты одного элеменнта взаимосвязи
2. Изебагть большого количества мелких сущностей
3. Компонент - чёрный ящик
4. Интерфейс

# Hello World
---
```c++
#include <iostream>

int main()
{
	std::cout << "Hello, World!" << std::endl;
}
```
---
# `STD`
`std` - пространство имён 
В нём определны функции, которые часто используются

---
```c++
using namespace std; //плохая практика
using std::cout, std::endl; //получше
```
---
Но лучше всегда писать `std::`
## Анонимные
---
```c++
namespace{
	int a;
}
```
---

# Синтаксис класса
---
```c++
class ClassName{
private:
		//закрытые члены класса (функции, типы и поля-данные)
public:
		//открытые члены класса (функции, типы и поля-данные)
protected:
		//защищённые члены класса


}[список_объектов];

Описание объектов - экземпляров класса:
ClassName obj, *pObj; //список слово class не требуется
```
---
# Члены, классы, поля
---
```c++
class X{
public:
	static constexpr double X_PI{3.14};
	int b{}, a = 1; // данные
	enum {e1, e2, e3} g;
	
	X(): b{1}, g(X::e1) {  // конструктор
		//тело конструктора
	}
	~X() {};//деструктор
	
	void foo(); //метод

private:
	int data_{}; //приватные данные
	
	struct inner {
		int i{}, j{};
		void g();
	};
	inner c;
}

int main()
{
	X x{};
	double d = X::X_PI; 
	x.a = 1;
	x.g = X::e2;
}
```
---
- `static` - в памяти лежит не в классе, а отдельно (отдельно в памяти)
- `int b{}` - инициализация по умолчанию
- инициализация в классе идёт последовательно, как мы их объявляем 
- *Конструктор* - способ инициализирования объекта определённого типа
	- `X x{}` - создается на стеке
	- `X(): b{1}, g(X::g1) {}` - сначала создастся `b{1}`, потом `g(X::g1)`
- *Деструктор* - способ уничтожить класс
- *Статические данные* через `::`, к остальным - `:`

# Действия над объектами классов
- Можем присваивать им значения
```c++
X x{};
X y{};
x = y;
```
- Получать адресс объекта (&) - *лучше указатели не использовать*
```c++
X *y = &x;
```
- Передавать объект в функцию
	- путём полного копирования объекта либо через ссылки
- Возвращать объект из функции
- Использовтаь методы

# АТД (абстрактный тип данных)
- тип данных с полностью скрытой (инкапсулярнной) структурой
- работа с переменными такого типа происходит только через *интерфейс* - специальные, предназначенные для этого функции
- В C++ АТД реализуется с помощью классов (структур), в которых нет *открытых* членов - данных
- Абстрактный класс - класс, содержащий чисто виртуальную ф-цию (нельзя создать объект, нужен для замены интерфейсов)

# Терминология
- *Оператор (statement)* - законченное действие
- *Операция (operator)* - используются в выражениях

- Для преобразования типов используются два термина - *преобразование (conversion)* и *приведение (cast)*

- *Приведение* - **не меняем данные**, просто их итерпретируем их как объект другого типа. Т.е. смотрим на данные по другому
	- `static_cast` - компилятор дополнительно проверяет
- *Преобразование* - **изменяем данные**

# Работа с динамической памятью
---
```c++
using T = int;
class TreeNode{
public:
	T value;
	TreeNode *parent{};
	TreeNode *left{}, *right{};
	TreeNode(T e, TreeNode *p): value(e), parent(p) {};
}

int main()
{
	TreeNode root{0, nullptr}; //stack
	root.left = new TreeNode{-42, &root}; //heap
	delete root.left;
	TreeNode **modesToDelete = new TreeNode*[10]; //not recommended
	delete[] nodesToDelet
}
```
---

# Проблемы с указателей
- разыменование `nullptr` (UB, segfault);
- невалидный (segfault, обращение к "чужой" памяти)
	- неинициализированный
	- освобождённый объект
	- ошибка вычислений: выход за границы буфера и т.п.
- утечка памяти - потеря последнего указателя

# Ссылочный тип
- **Ссылка (reference)** - некоторая переменная, которая типа указатель, но не указатель. Псевдоним, *несколько имён на одну ячейку памяти*
---
```c++
void swap(int& first, int& second)
{
	int temp = first;
	first = second;
	second = temp;
}
```
---
- Единственная **операция над ссылками** - **инициализация** при создании
- именует тот же **адрес** памяти, что и её инициализатор
- L-value выражение
- является алиасом (псевдоним) инициализатора
- В отличие от указателей ссылка не может быть не инициализирована, не может быть изменена
- Может использоваться для передачи и возврата значений в/из функции

## Примеры
### Lvalue ссылка
----
```c++
int x = 5;
int& ref = x; // ref - ссылка на x
ref = 10; // x теперь равно 10
```
----
### Rvalue ссылка (C++11)
---
```c++
int&& rref = 5; //может ссылаться на временный объект
```
---
1. Создаётся временный объект типа `int` со значением `5`.  
    (Обычно размещает его на стеке, но это деталь реализации.)
2. Привязывает ссылку `rref` к этому временному объекту.
3. **Продлевает время жизни** временного объекта до конца времени жизни ссылки `rref`.  
	-  Без ссылки временный объект `5` существовал бы только в пределах выражения.  
	- Благодаря ссылке объект живёт, пока жива `rref`.
### Const ссылка
---
```c++
const int& cref = x;
```
---
### Не могут быть null (в корректном коде)
---
```c++
int* ptr = nullptr;
int& ref = *ptr; //UB
```
---