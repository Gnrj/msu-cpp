# Trailing return type

---
```c++
auto ggg(auto x) -> decltype(x)::value_type
{

}
```
---


# Классы и структуры

**ООП** - программа, в которой есть объект

**Объект** - некоторая сущность, которая существует внутри работы программы. Под объект выделяется память

**Класс** - тип данных

Ключевое слово `struct` и `class`. 

---
```c++
#include <print>
#include <iostream>

struct C1
{
//public
	int x;
};

//private, protected, public
class C2
{
//private
	int x;
};


int main()
{
	C1 a;
	a.x = 10; //right

	C2 a2;
	a2.x = 20; //error

}
```
---

- `public` - означает, что переменная видна наружу данного типа
- `private` - не видна наружу
- `protected` - не видна наружу, но только для производных классов 

---
```c++
#include <print>
#include <iostream>

struct C1 //может работать как namespace
{
	static constexpr int C = 10; //C известно на этапе компиляции
	
	//static int D = 20; //error
	static int D; //деклорация переменной, нужно где-то её будет ещё объявить
	
	int x{1000}; //всегда указываем, чтобы не было UB
	
	using T = int; //using синоним typedef, только в пространстве имён C1

	static auto f1() -> T 
	{
		return C+1;
	}

	auto f2(/*C1 * this */) -> T
	{
		return this->x + 100;
	}

	auto f3(/*const C1 * this */) const -> T // функция приминима к константным объектам
	{
		return x + 200; 
	}

	auto f4(this C1 &that) -> T // может отказаться от неявного that
	{
		return that.x + 300;
	}
};

int C1::D{20};

int main()
{
	C1 a, b;
	std::println("{}", C1::C); //10
	
	C1::T y{20};
	std::println("{} {}", y, sizeof(y)); // 20
	
	std::println("{}", C1::f1()); //11
	
	std::println("{} {}", a.f2(), b.f2()); //1100 1100

	const C c;
	std::println("{}", c.f3());
	std::println("{}", c.f4());
}
```
---

- `static` - не является полем, является сущностью, которая относится не к объекту, а пространству имён C 

- С `x` будем работать по смещению относительно начала нашей структуры

- `static` функция не может работать с полями нашего класса. Просто функция, которую поместили в пространство имён C1. Никак не связана с *объектами* C1

- НЕ `static` функция привязана к объекту этого класса. У неё есть *скрытый* параметр `this` (указатель, который даёт доступ к соответствующему объекту) 
 
# Конструктор и деструктор

- В жизни объекта есть 2 особых момента: это его создание и его уничтожение.

---
```c++
#include <print>
#include <iostream>
#include <vector>

struct A
{
	int x{100};
	double y{1.5};
	bool z{true};
	std::vector<int> v; //вызовет конструктор vector 

	//A() = default; //сгенерирует конструктор в явном виде
	//A() = delete; //запрещаем генерацию конструткора по умолчанию
	// default
	A() : y{2.0} //инициализация, а не присвоение 
	{
		x = 101; //это не инициализация, это присвоение уже существующему полю
		std::println("{}", __PRETTY_FUNCTION__); //A::A()
	}

	A(int xx): x{xx}
	{
	}

	~A(){
		std::println("{}", __PRETTY_FUNCTION__); //~A::A()
	}
};

A g; // в этом случае A создаётся перед работы функции main. Можем считать что память как бы уже выделена, нужно лишь её проинициализировать


int main()
{
	A a1;

	{
		A a2;
	}

	A a3(10);
	A a4{20};
}
```
---

- В момент создания вызывается специальная функция `Конструктор`, которая инициализирует все не `static` поля в порядке их объявления в классе

- Конструктор, который не принимает никакие поля - называется **конструктор по умолчанию**

- Деструктор вызывается, кто объект уничтожается. Вызываются в обратном порядке (a2, a4, a3, a1, g)

---
```c++
#include <iostream>
#include <vector>

struct A
{
	int x_{};

	A() = default; //заставляем генерировать конструктор по умолчанию
	A(int x): x_{x}
	{

	}
}

void f(A a)
{
	std::println("{}", __PRETTY_FUNCTION__);
}

int main()
{
	A a;

	f(1); //void f(A)

	std::vector<int> v(10); //опеределение вектора с 10 элементами 0-лями
}
```
---

Как только написали конструктор, **отваливается** конструктор по умолчанию

## `explicit`

---
```c++
#include <iostream>
#include <vector>

struct A
{
	int x_{};

	A() = default; //заставляем генерировать конструктор по умолчанию
	explicit A(int x): x_{x}
	{

	}
}

void f(A a)
{
	std::println("{}", __PRETTY_FUNCTION__);
}

int main()
{
	A a;

	f(1); //error
	f(1.0); //error
	f(100LL); //error

	f(A(1));
	f(A(1.0));
	f(A(100LL));

	A b{1.5}; //запрет сужающего преобразования (error)
}
```
---

Ключевое слово `explicit` запрещает неявное преобразование в конструкторе

## Специальная форма конструктора
---
```c++
#include <iostream>
#include <vector>

struct A
{
	int x_{};

	A() = default; //заставляем генерировать конструктор по умолчанию
	explicit A(int x): x_{x}
	{
		std::println("{}", __PRETTY_FUNCTION__);
	}

	A(std::initializer_list<int> l) 
	{
		x_ = *l.begin();
		std::println("{}", __PRETTY_FUNCTION__);
	}
}

void f(A a)
{
	std::println("{}", __PRETTY_FUNCTION__);
}

int main()
{
	A a;

	f(1); //error
	f(1.0); //error
	f(100LL); //error

	f(A(1));
	f(A(1.0));
	f(A(100LL));

	A b{1}; //
	A c(1.5);
}
```
---

После появления `A(std::initializer_list<int> l)`, вызовы `A b{1}` и `A c(1.5)` стали разными

## `constexpr` и оператор `bool`

---
```c++
#include <iostream>
#include <vector>

struct A
{
	static constexpr auto C = 10;

	int x_{};

	A() = default; //заставляем генерировать конструктор по умолчанию
	
	constexpr A(int x) noexcept: x_{x} //можем использовать его в константном контексте
	{
	}

	operator bool () const noexcept { return bool(x_); }

	constexpr auto get() const noexcept -> int {return x};



}

int m[A(10).get()];

void f(A a)
{
	std::println("{}", __PRETTY_FUNCTION__);
}

int main()
{
	A a;

	f(1); //error
	f(1.0); //error
	f(100LL); //error

	f(A(1));
	f(A(1.0));
	f(A(100LL));

	std::println("{}", sizeof(m)); //40

	bool b1{A{10}}; 
	int v2{A{20}}; //есть объект типа A, его преобразуем в bool 
	std::println("{}", v2) // 1
}
```
---

`noexcept` это утверждение, что данная функция не выбрасывает **исключений**. Очень хорошо помогает компилятору оптимизировать код. Деструкторы `noexcept` по умолчанию


Оператор `bool` преобразует x_ в `bool`


## ограничение оператора `bool` (`explicit`)

---
```c++
#include <iostream>
#include <vector>

struct A
{
	static constexpr auto C = 10;

	int x_{};

	A() = default; //заставляем генерировать конструктор по умолчанию
	
	constexpr A(int x) noexcept: x_{x} //можем использовать его в константном контексте
	{
	}

	constexpr explicit operator bool () const noexcept { return bool(x_); }

	constexpr auto get() const noexcept -> int {return x};

	constexpr ~A()
	{
	}
}

int m[A(10).get()];

void f(A a)
{
	std::println("{}", __PRETTY_FUNCTION__);
}

int main()
{
	A a;

	f(1); //error
	f(1.0); //error
	f(100LL); //error

	f(A(1));
	f(A(1.0));
	f(A(100LL));

	if(A(10)){

	}

	std::println("{}", sizeof(m)); //40

	bool b1{A{10}}; 
	int v2{A{20}}; //error
}
```
---

## Несколько аргументов

---
```c++
struct A
{
	int c_{};

	constexpr A(int a, int b): c_{a+b} {}
};
```
---

# Именование сущностей внутри класса

2 школы мыслей:

## Google и все кто их копирует

---
```c++
class A
{
	int x_;

public:
	//returns x
	constexpr auto x() const noexcept {return x_;}
	//sets x
	void set_x(int x) noexcept { x_ = x; }
}
```
---

- **рекомендованный**

## Другая школа мысли

---
```c++
class B
{
	int m_x;

public:
	//returns x
	constexpr auto get_x() const noexcept {return m_x;}
	//sets x
	void set_x(int x) noexcept { m_x = x; }
}
```
---







