# Константность 
---
```c++
#include <iostream>
#include <print>

const int N = 10;
```
---

- `const` - вычисляет на этапе компиляция
- `const` - защищённое место в памяти

---
```c++
#include <iostream>
#include <print>

const int N = 10;

int a1[N]; //вычисляется на этапе компиляции

int main()
{
    std::println("{}", sizeof(a1));
}
```
---

## 2 программа

---
```c++
#include <print>

extern const int N;

void foo()
{
    std::println("{}", N);
}

```
---

- Не скомпилируется, так как `const` не даёт увидеть N во второй программе

## 3 программа 

---
```c++
#include <iostream>
#include <print>

extern const int N;

const int N = 10;

int a1[N]; //вычисляется на этапе компиляции

void foo();

int main()
{
    std::println("{}", sizeof(a1));
    foo();
}
```
---
```c++
#include <print>

extern const int N;

void foo()
{
    std::println("{}", N);
}

```
---

- Данная программа скомпилируется

# `constexpr`

---
```c++
#include <iostream>
#include <print>

extern const int N;

const int N = 10;

int a1[N];

void foo();

constexpr int K;

char a2[K];

int main()
{
    std::println("{}", sizeof(a1));
    std::println("{}", sizeof(a2));
    foo();
}
```
---

## `Константные функции`

---
```c++
#include <iostream>
#include <print>

extern const int N;

const int N = 10;

int a1[N];

void foo();

constexpr int K;

char a2[K];

constexpr int f(int n) 
{
    int r = 1;
    for(int i = 1; i <= n; ++i){
        r *= i;
    }
    return i;
}

char a3[f(N)]; //f(N) вычисляется на этапе компиляции

int main()
{
    std::println("{}", sizeof(a1));
    std::println("{}", sizeof(a2));
    std::println("{}", sizeof(a3));
    foo();
    int x;
    cin >> x;
    int y = f(x);
    std::println("{}", y);
}
```
---

### 2 программа

---
```c++
#include <iostream>
#include <print>
#include <time.h>

extern const int N;

const int N = 10;

int a1[N];

void foo();

constexpr int K;

char a2[K];

constexpr int f(int n) 
{
    int r = time(0);
    for(int i = 1; i <= n; ++i){
        r *= i;
    }
    return i;
}

char a3[f(N)]; //error (не может быть вычислено на этапе компиляции)

int main()
{
    std::println("{}", sizeof(a1));
    std::println("{}", sizeof(a2));
    std::println("{}", sizeof(a3));
    foo();
    int x;
    cin >> x;
    int y = f(x);
    std::println("{}", y);
}
```
---

## `consteval`

---
```c++
#include <iostream>
#include <print>
#include <time.h>

extern const int N;

const int N = 10;

int a1[N];

void foo();

constexpr int K;

char a2[K];

consteval int f(int n) 
{
    int r = 1;
    for(int i = 1; i <= n; ++i){
        r *= i;
    }
    return i;
}

char a3[f(N)];

int main()
{
    std::println("{}", sizeof(a1));
    std::println("{}", sizeof(a2));
    std::println("{}", sizeof(a3));
    foo();
    int x;
    cin >> x;
    int y = f(x); //error (не константное выражение)
    std::println("{}", y);
}
```
---

- Отличия: 
  1. нельзя вызывать не в константом выражении
  2. нельзя использовать в не константом контексте (компилятор должен уметь вычислять значение на этапе компиляции)

# Автовывод типов

---
```c++
#include <iostream>
#include <print>

int main()
{
    auto x = 10; 

    [[maybe_unused]] //аттрибут, чтобы показать, что переменная может не использоваться
    auto y = x;

    const int a = 10;
    [[maybe_unused]] auto b = a; // будет тип `int`

    int &c = a;
    [[maybe_unused]] auto d = c; // int

    int *e = 0;
    auto f = e; //указатель

    const auto &g = c;

    std::println("{} {}", sizeof(e), sizeof(f));
}
```
---

## `decltype`

---
```c++
#include <iostream>
#include <print>
#include <type_traits>

int main()
{
    auto x = 10; 

    [[maybe_unused]] //аттрибут, чтобы показать, что переменная может не использоваться
    auto y = x;

    const int a = 10;
    [[maybe_unused]] auto b = a; // будет тип `int`

    int &c = a;
    [[maybe_unused]] auto d = c; // int

    int *e = 0;
    auto f = e; //указатель

    [[maybe_unused]] decltype(a) g = a; //будет иметь тот же самый тип, что и a
    decltype(c) h = c;

    std::println("{} {}", sizeof(e), sizeof(f));
    std::println("{}", std::is_same_v<decltype(h), int&>); //проверяет соответствие типов
    std::println("{}", std::is_same_v<std::decay_t<decltype(h)>, int>); 
}
```
---

- `decay_t<>` - отбрасывает `const`, `volatile` и ссылочность

## `auto функции`

---
```c++
#include <iostream>
#include <print>

auto func(int a) -> int //просто перенесли тип возвращаемой функции вправо
{
    std::println("{}", __PRETTY_FUNCTION__);
    return a+1;
}

auto func2(int a) // должны на этапе компиляции знать, что какой тип возвращать
{
    std::println("{}", __PRETTY_FUNCTION__);
    if(a < 0){
        return double(a); //error, так как тип int и double
    }
    return a+1;
}

int main()
{
    int x;
    std::cin >> x;
    std::println("{}", func(x));
}
```
---

## `auto` в аргументах

---
```c++
#include <iostream>
#include <print>

auto func(int a) -> int
{
    std::println("{}", __PRETTY_FUNCTION__);
    return a+1;
}

auto func2(int a) 
{
    std::println("{}", __PRETTY_FUNCTION__);
    if(a < 0){
        return double(a) 
    }
    return double(a)+1;
}

auto func3(auto a) -> decltype(a)
{
    std::println("{}", __PRETTY_FUNCTION__);
    return a + 1;
}

int main()
{
    int x;
    std::cin >> x;
    std::println("{}", func(x));
    std::println("{}", func2(x));
    std::println("{}", func3(x));
    std::println("{}", func3(char(x)));
    int &y = x;
    std::println("{}", func3(y)); //передаст тип int, так как ссылочность отброситься
}
```
---

# Инициализация

---
```c++
#include <iostream>
#include <print>

int main()
{
    int a = 10;

    int b = int(a); //явное приведение типа или вызов типа конструктора 
    int c(a);

    int d(); //most vexing parse -> function

    int f; //UB, будет не мусор, а хз что

    int e = { 11 };

    int g{11};

    int h{}; //инициализация нулём

    std::vector vv{1, 2, 3, 4};

    long l = 100;

    int m(l); // long -> int
    int n{l}; //ERROR
}
```
---
