# Понятие категории значения
- *value categories*

В Си:
  - *rvalue* - выражение
  - *lvalue* - какая-то переменная, которая имеет какую-то область в памяти

C++ дополнил классификацию

**Базовая категория в C++**: 
  - **lvalue** - то от чего можно взять адрес. Любой идентификатор переменной, который обозначает переменную.
    - *variable ident*: a, cout
    - *lvalue выражения*: a += b, ++a, *p, a[i], a.m, p->m
    - *ссылочные ссылки*: int &f(); -> f(). Использование f() здесь это lvalue (так как возвращаем ссылку)
  
  - **prvalue(pure r-value)** - "чисто rvalue" (нельзя взять адрес)
    - *литералы*: 10, 'c', 1.0, X (enum const), 
    - *выражение*: a++, a + b, &a, this, []() "лямбда выражения"
    - *результат работы функции*: A f(); -> f()

  - **xvalue (expiring value)** - связана с временем жизни объектов. Есть адрес, но *ненадолго*
    - A f(); f().m
    - int &&f(); -> f()
    - *временный объект (temporary obj after materialization)*:  
    - *temporary materialization*: const int &a{10}; a ссылочный тип. Ссылка должна ссылаться на какой-то объект, **создаст временный объект**. Важно что здесь ссылка const. Произошла материализация 
    - return x; throw x;

  - **glvalue (generalized value)** = lvalue | xvalue (всё от чего можно взять адрес)

  - **rvalue** = prvalue | xvalue

```c++
int b
a = b; //здесь b - lvalue (-> impilicit lvalue to rvalue conversation)
a = b = 10; // -> a = (b = 10) -> C/C++ (присваивание - lvalue (в C++)) 
(a = b) = c; // -> C++ only
```
есть большое количество неявных преобразований:
  - преобразование массива в адрес его начала
  - int в long
  - преобразование lvalue в rvalue

# Ссылки
---
```c++
#include <print>
#include <iostream>

using namespace std;

struct A
{
    int m{};
};

int f()
{
    return 1;
}

int main()
{
    // x
    int a{0};

    int &b{a};
    int &c{b}; //и c и b ссылки на a

    a = 10;
    println("{} {} {}", a, b, c); //10 10 10
    
    b = 20; //модификация переменной, на которую мы ссылаемся
    println("{} {} {}", a, b, c); //20 20 20

    auto d = b; // выполняется неявное преобразование lvalue -> rvalue (std::decay_t) (ссылочность отбрасывается)

    println("{}", A().m) //A().m - prvalue, оно материлизуется (так как нужен временный объект)

    //auto &e = A().m; // некорректное выражение

    //live time следующих переменных продлена до времени жизни ссылок, которые на них ссылаются
    int &&e = A().m //rvalue ссылка может ссылаться на xvalue. 
    int &&f = 10; //это материализованные временные объекты

    println("{} {}", e, f);
}
```
---

Мотивация из-за структур. Они могут иметь большие значени. Их копирования это существенные накладные расходы. Если передаём по значению, то только копирование

Ссылочный тип можно описывать как некий *alias* => ссылки должны **всегда на что-то указывать**

---
```c++
{
    int &&e = A().m 
    int &&f = 10; //rvalue ссылка, но само f это lvalue

    println("{} {}", e, f); //0 10

    f = 20;
    println("{} {}", e, f); //0 20

    //int &&g = f; //некорректная запись (так как f это lvalue)
    int &h = f; //можем получить lvalue ссылку, так как f это lvalue
    println("{}", h); //20
    
    int &&g = static_cast<int&&>(f);
    int &&r1 = (int&&) f;
    int &&r2 = std::move(f); //обычный static_cast в соответствующий тип
}
```
---

## Константные ссылки
---
```c++
const int &&r2 = std::move(f); //можно, а зачем?

const int &r3 = b; //константная lvalue ссылка, запрещаем модификацию через ссылку

const int &r4 = 10; //константная lvalue ссылка может быть инициализирована константой
```
---

# Простой случай перегрузки

## 1 программа

---
```c++
#include <print>
#include <iostream>

using namespace std;

auto f(int a)
{
    println("{}, __PRETTY_FUNCTION__"); 
}

int main()
{
    int b = 20;
    const int c = 30;
    int &d = b;
    const int &e = c;
    int &&h = 40;
    const int &&g = 40;
    
    f(10); //auto f(int)
    f(b); //auto f(int)
    f(c); //auto f(int)
    f(d); //auto f(int)
    f(e); //auto f(int)
    f(h); //auto f(int)
    f(g); //auto f(int)
}

```
---

## 2 программа

---
```c++
#include <print>
#include <iostream>

using namespace std;

auto f(int a)
{
    println("{}, __PRETTY_FUNCTION__"); 
}

auto f(int &a) //error
{
    println("{}, __PRETTY_FUNCTION__"); 
}

int main()
{
    int b = 20;
    const int c = 30;
    int &d = b;
    const int &e = c;
    int &&h = 40;
    const int &&g = 40;
    
    f(10);
    f(b); //неявное преобразование lvalue -> rvalue, поэтому будет двоякий вызов и сломается компилятор
}
```
---

## 3 программа

---
```c++
#include <print>
#include <iostream>

using namespace std;

auto f(int &a)
{
    println("{}", __PRETTY_FUNCTION__);
}

auto f(const int &a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

auto f(int &&a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

auto f(const int &&a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

int main()
{
    int b = 20;
    const int c = 30;
    int &d = b;
    const int &e = c;
    int &&h = 40;
    const int &&g = 40;
    
    f(10); //auto f(int &&)
    f(b); // auto f(int &)
    f(c); //auto f(const int &)
    f(d); //auto f(int &)
    f(e); // auto f(const int &)
    f(h); //auto f(int&)
    f(g); //auto f(const int&)
}
```
---

Компилируется, но компилятор всегда хочет передавать lvalue

## 4 программа

---
```c++
#include <print>
#include <iostream>

using namespace std;

auto f(int &a)
{
    println("{}", __PRETTY_FUNCTION__);
}

auto f(const int &a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

auto f(int &&a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

auto f(const int &&a)
{
    println("{}", __PRETTY_FUNCTION__); 
}

int main()
{
    int b = 20;
    const int c = 30;
    int &d = b;
    const int &e = c;
    int &&h = 40;
    const int &&g = 40;
    
    f(10); //auto f(int &&)
    f(b); // auto f(int &)
    f(c); //auto f(const int &)
    f(d); //auto f(int &)
    f(e); // auto f(const int &)
    f(std::move(h)); //auto f(int&&)
    f(std::move(g)); //auto f(const int&&)
}
```
---

Для чего это нужно? Выстроить непротиворечивую move семантику

# RVO

## 1 программа

---
```c++
#include <print>
#include <iostream>

using namespace std;

struct A
{
    int m;
}

A f()
{
    return A();
}

int main()
{
    //RVO - return value optimization
    auto a{f()};
}
```
---

Здесь вообще не будет копирования. Это в современной C++ обязательная оптимизация: убрать все копирования.

## 2 программа
---
```c++
#include <print>
#include <iostream>

using namespace std;

struct A
{
    int m;
}

A f()
{   
    A a;
    return a;
}

int main()
{
    //NRVO - named return value optimization
    auto a{f()};
}
```
---

Здесб максимум *одно*. Но компилятор тоже может это оптимизировать, и будет 0 копирований

## 3 программа
---
```c++
#include <print>
#include <iostream>

using namespace std;

struct A
{
    int m;

    A () = default;
    A(const A &other) : m{other.m} { //конструктор копирования
        println("here");
    } 
}

A f()
{   
    A a;
    return a;
}

int main()
{
    //NRVO - named return value optimization
    auto a{f()};
}
```
---

Конструктор не вызывается: компилятор может игнорировать специальные конструкторы (компилятор их оптимизирует)

# Классы

---
```c++
#include <print>
#include <iostream>

struct A //или class //ведёт себя как namespace
{
    int m;

    static constexpr int n = 10; //constexpr не может быть static в классе!!!
    static inline int p = 20; //помещеная в область видимости A

    static int q; //декларация переменной q
};

int A::q = 100; //обязательно инициализировать вне класса!!!

using namespace std;

int main()
{
    //A::m = 10; //error
    println("{}", A::n); //находится в пространстве имён A
    A::p += 20;
    println("{}", sizeof(A)); //4 - здесь n, p и q включены не будет
    
    println("{}", p); //40
}

```
---

`struct` и `class` отличаются только видимостью переменных **по умолчанию!!!**
  - В `struct` все поля публичные по умолчанию
  - В `class` все поля по умолчанию `private`

- `inline` объявляет статические переменные класса